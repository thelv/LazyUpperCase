#include <iostream>
#include <windows.h>
#include <winuser.h>
#include <io.h>
#include <fcntl.h>

// Global handle for the keyboard hook
HHOOK g_hHook;

// Global variable to track the last pressed key's virtual code
DWORD g_lastVkCode = 0;
// Global flag to track if a repeat has already been logged
int g_repeatCount = 0;
// Global flag to prevent the hook from processing events sent by our program
bool g_isSending = false;

BYTE keyState[256] = {}; //fake zero state, just to ToUnicodeEx work (anyway it doesn't influence somewhy)

// Hook procedure that processes keyboard events
// This function is called by the OS every time a key event occurs
LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam) {
    // If the event was generated by our own SendInput, we pass it through without processing.

    if (g_isSending) {
        return CallNextHookEx(g_hHook, nCode, wParam, lParam);
    }

    // --- New Event ---
    std::cout << "---" << std::endl;
    std::cout << "DEBUG: Event received. nCode: " << nCode << ", wParam: " << wParam << std::endl;

    // We only process events if the nCode is not less than zero
    if (nCode >= 0) {        
        std::cout << "DEBUG: nCode is valid. Checking for keydown/keyup event." << std::endl;
        // Get a pointer to the low-level keyboard hook structure
        KBDLLHOOKSTRUCT* pKeyInfo = (KBDLLHOOKSTRUCT*)lParam;

        // Check for keydown events
        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            std::cout << "DEBUG: Keydown event confirmed. VK code: " << pKeyInfo->vkCode << std::endl;            

            if(pKeyInfo->vkCode == VK_BACK || pKeyInfo->vkCode == VK_TAB || pKeyInfo->vkCode == VK_SPACE || pKeyInfo->vkCode == VK_RETURN) {
                std::cout << "DEBUG: Space symbol is pressed. Passing event." << std::endl;
                return CallNextHookEx(g_hHook, nCode, wParam, lParam);
            }

            // Use GetAsyncKeyState to check for modifier keys directly
            bool isCtrlPressed = (GetAsyncKeyState(VK_CONTROL) & 0x8000);
            bool isShiftPressed = (GetAsyncKeyState(VK_SHIFT) & 0x8000);
            bool isAltPressed = (GetAsyncKeyState(VK_MENU) & 0x8000);

            // If any of the modifier keys are pressed, we pass the event through.
            if (isCtrlPressed || isShiftPressed || isAltPressed) {
                std::cout << "DEBUG: Modifier key is pressed. Passing event." << std::endl;
                return CallNextHookEx(g_hHook, nCode, wParam, lParam);
            }

            // If no modifiers are pressed, we check if the key is a printable character.
            // A non-zero result from ToUnicodeEx indicates a printable character.
            
            WCHAR unicodeChar[5];
            HKL hkl = GetKeyboardLayout(GetWindowThreadProcessId(GetForegroundWindow(), NULL));

            int result = ToUnicodeEx(
                pKeyInfo->vkCode,
                pKeyInfo->scanCode,
                keyState, 
                unicodeChar,
                5,
                0,
                hkl
            );

            std::cout << "DEBUG: ToUnicodeEx returned: " << result << std::endl;
            if (result > 0) {
                // It's a printable key with no modifiers.
                // Now we apply the new repeat logic.

                // --- Check for repeats ---
            if (pKeyInfo->vkCode == g_lastVkCode) {
                // This is a repeat press. Increment the counter.
                g_repeatCount++;
                std::cout << "DEBUG: Repeat press detected. Repeat count: " << g_repeatCount << std::endl;
            } else {
                // If it's a new key, reset the repeat flag and log
                g_repeatCount = 0;
                std::cout << "DEBUG: New key press detected." << std::endl;
            }

            // Update the last pressed key's virtual code
            g_lastVkCode = pKeyInfo->vkCode;

                if (g_repeatCount == 0) {
                    // This is the first press. Pass it through as is.
                    std::cout << "DEBUG: First press detected. Passing event." << std::endl;
                    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
                } else if (g_repeatCount == 1) {
                    // This is the first repeat. We block it and send the shifted version.
                    std::cout << "DEBUG: Blocking first repeat and sending shifted character. Virtual Key: " << pKeyInfo->vkCode << std::endl;

                    // --- Simulate a backspace to remove the original character ---
                    INPUT input[6] = {};

                    // 1. Backspace key down
                    input[0].type = INPUT_KEYBOARD;
                    input[0].ki.wVk = VK_BACK;

                    // 2. Backspace key up
                    input[1].type = INPUT_KEYBOARD;
                    input[1].ki.wVk = VK_BACK;
                    input[1].ki.dwFlags = KEYEVENTF_KEYUP;

                    // --- Simulate a shifted key press and send it ---
                    // 3. Key down event for SHIFT
                    input[2].type = INPUT_KEYBOARD;
                    input[2].ki.wVk = VK_SHIFT;

                    // 4. Key down event for the original key
                    input[3].type = INPUT_KEYBOARD;
                    input[3].ki.wVk = pKeyInfo->vkCode;

                    // 5. Key up event for the original key
                    input[4].type = INPUT_KEYBOARD;
                    input[4].ki.wVk = pKeyInfo->vkCode;
                    input[4].ki.dwFlags = KEYEVENTF_KEYUP;

                    // 6. Key up event for SHIFT
                    input[5].type = INPUT_KEYBOARD;
                    input[5].ki.wVk = VK_SHIFT;
                    input[5].ki.dwFlags = KEYEVENTF_KEYUP;

                    // Set the flag to prevent re-processing the events we are about to send
                    g_isSending = true;

                    // Send the input
                    SendInput(6, input, sizeof(INPUT));

                    // Reset the flag after sending
                    g_isSending = false;

                    return 1;
                } else {
                    // This is the second or more repeat. Ignore it.
                    std::cout << "DEBUG: Ignoring subsequent repeat. Blocking event." << std::endl;
                    return 1;
                }
            } else {
                // It's a non-printable key, so we pass it through.
                std::cout << "DEBUG: Passing non-printable keydown event. Virtual Key: " << pKeyInfo->vkCode << std::endl;
                return CallNextHookEx(g_hHook, nCode, wParam, lParam);
            }
        }
        // Check for keyup events
        else if (wParam == WM_KEYUP || wParam == WM_SYSKEYUP) {
            std::cout << "DEBUG: Keyup event confirmed." << std::endl;
            KBDLLHOOKSTRUCT* pKeyInfo = (KBDLLHOOKSTRUCT*)lParam;

            // Check if this keyup matches the last keydown
            if (pKeyInfo->vkCode == g_lastVkCode) {
                std::cout << "DEBUG: Keyup matches last keydown. Resetting state." << std::endl;
                // Reset the global variables
                g_lastVkCode = 0;
                g_repeatCount = 0;
            } else {
                std::cout << "DEBUG: Keyup does not match last keydown. No state change." << std::endl;
            }
            // Pass the event to the next hook in the chain
            return CallNextHookEx(g_hHook, nCode, wParam, lParam);
        }
    }

    std::cout << "DEBUG: Event is not a keydown/keyup, passing it along." << std::endl;
    // Pass the event if nCode is less than zero or it's not a key-down event
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}

int main() {
    // Set the low-level keyboard hook
    g_hHook = SetWindowsHookEx(
        WH_KEYBOARD_LL,
        KeyboardHookProc,
        GetModuleHandle(NULL),
        0
    );

    if (g_hHook == NULL) {
        std::cerr << "ERROR: Failed to set keyboard hook." << std::endl;
        return 1;
    }

    std::cout << "DEBUG: Keyboard hook successfully installed. Press 'ESC' to exit." << std::endl;

    // Message loop to keep the application running and processing events
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        // Just process messages to keep the application alive
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        // Check if the escape key was pressed to exit the loop
        if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE) {
            break;
        }
    }

    // Unhook the keyboard hook when the message loop terminates
    UnhookWindowsHookEx(g_hHook);
    std::cout << "DEBUG: Keyboard hook successfully uninstalled." << std::endl;

    return 0;
}
